{
  "hash": "950cbe5ab6ac250b3dd825cda55070bc",
  "result": {
    "markdown": "---\ntitle: This is a blog post on regression.\ndate: '2022-06-01'\ncategories:\n  - '123'\n  - Second Tag\ndescription: This is a blog post on regression. I will use the Seaborn Diamonds dataset to predict the price of a diamond based on other features about it.\nexecute:\n  message: false\n  warning: false\neditor_options:\n  chunk_output_type: console\n---\n\nIn this blog post, I will use the Seaborn Diamonds dataset to predict the price of a diamond based on various features of that diamond, like color, cut, and depth. Through this exercise, I hope to learn which features of a diamond contribute most to its price. \n\n# Get and Examine the Data\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n# sns.get_dataset_names()\ndiamonds = sns.load_dataset('diamonds')\ndiamonds.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>carat</th>\n      <th>cut</th>\n      <th>color</th>\n      <th>clarity</th>\n      <th>depth</th>\n      <th>table</th>\n      <th>price</th>\n      <th>x</th>\n      <th>y</th>\n      <th>z</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>0.23</td>\n      <td>Ideal</td>\n      <td>E</td>\n      <td>SI2</td>\n      <td>61.5</td>\n      <td>55.0</td>\n      <td>326</td>\n      <td>3.95</td>\n      <td>3.98</td>\n      <td>2.43</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>0.21</td>\n      <td>Premium</td>\n      <td>E</td>\n      <td>SI1</td>\n      <td>59.8</td>\n      <td>61.0</td>\n      <td>326</td>\n      <td>3.89</td>\n      <td>3.84</td>\n      <td>2.31</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>0.23</td>\n      <td>Good</td>\n      <td>E</td>\n      <td>VS1</td>\n      <td>56.9</td>\n      <td>65.0</td>\n      <td>327</td>\n      <td>4.05</td>\n      <td>4.07</td>\n      <td>2.31</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>0.29</td>\n      <td>Premium</td>\n      <td>I</td>\n      <td>VS2</td>\n      <td>62.4</td>\n      <td>58.0</td>\n      <td>334</td>\n      <td>4.20</td>\n      <td>4.23</td>\n      <td>2.63</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>0.31</td>\n      <td>Good</td>\n      <td>J</td>\n      <td>SI2</td>\n      <td>63.3</td>\n      <td>58.0</td>\n      <td>335</td>\n      <td>4.34</td>\n      <td>4.35</td>\n      <td>2.75</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nLet's examine the columns and their data types. We will also check for null and missing values. \n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\ndiamonds.shape\ndiamonds.info()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 53940 entries, 0 to 53939\nData columns (total 10 columns):\n #   Column   Non-Null Count  Dtype   \n---  ------   --------------  -----   \n 0   carat    53940 non-null  float64 \n 1   cut      53940 non-null  category\n 2   color    53940 non-null  category\n 3   clarity  53940 non-null  category\n 4   depth    53940 non-null  float64 \n 5   table    53940 non-null  float64 \n 6   price    53940 non-null  int64   \n 7   x        53940 non-null  float64 \n 8   y        53940 non-null  float64 \n 9   z        53940 non-null  float64 \ndtypes: category(3), float64(6), int64(1)\nmemory usage: 3.0 MB\n```\n:::\n:::\n\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n# Check for any null values. \ndiamonds.isna().any().any()\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\nFalse\n```\n:::\n:::\n\n\nLooks like this dataset doesn't contain any null values, so we don't have to interpolate missing values. \n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\n# Let's find the minimum and maximum price for any individual diamond. \n[diamonds['price'].min(), diamonds['price'].max()]\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n[326, 18823]\n```\n:::\n:::\n\n\nIt appears the price of the diamonds is in a very large range. The price varies from a couple hundred dollars on the low-end to around $19K on the high end. Let's also examine the other quantitative variables, to ensure they are correct. \n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\n[diamonds['carat'].min(), diamonds['carat'].max()]\n[diamonds['depth'].min(), diamonds['depth'].max()]\n[diamonds['table'].min(), diamonds['table'].max()]\n[diamonds['x'].min(), diamonds['x'].max()]\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n[0.0, 10.74]\n```\n:::\n:::\n\n\nSo far, carat, depth, and table seem to have a reasonable range. However, the x-min is 0.0. It is not possible for the x-dimension of the diamond to be zero (otherwise it would be flat), so this seems suspicious. Let's see if the same problem appears for the y and z dimensions. \n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\n[diamonds['y'].min(), diamonds['z'].min()]\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n[0.0, 0.0]\n```\n:::\n:::\n\n\nIndeed, the y and z dimensions also have min values of 0. Let's remove these entries from the dataframe before we do any further processing. \n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\ndiamonds = diamonds[(diamonds[['x', 'y', 'z']] != 0).all(axis=1)]\ndiamonds.shape\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n(53920, 10)\n```\n:::\n:::\n\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\n# Print out the new minimum values for all three variables. \n[diamonds['x'].min(), diamonds['y'].min(), diamonds['z'].min()]\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n[3.73, 3.68, 1.07]\n```\n:::\n:::\n\n\nThese new minimum values look much better.  \nLet's now get a better sense for the price variability by plotting the diamond price via a histogram. \n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nsns.histplot(data=diamonds, x=\"price\")\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n<Axes: xlabel='price', ylabel='Count'>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-10-output-2.png){width=601 height=429}\n:::\n:::\n\n\nThis visualization gives us further insight into the price of the diamonds. It seems that most of the diamonds are on the low end, but there are a few very expensive diamonds.\n\nNow, let's identify which factors most affect a given diamond's price. First, let's identify what factor the diamond carat (weight) has on price. We can visualize this relationship through a scatterplot. \n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\n# TODO: Ask about this plot. \nsns.scatterplot(data=diamonds, x=\"carat\", y=\"price\", size=1, alpha=0.6, edgecolor=None)\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n<Axes: xlabel='carat', ylabel='price'>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-11-output-2.png){width=610 height=429}\n:::\n:::\n\n\nIt seems there is a lot of noise that somewhat degrades the quality of the plot. There is a lot of variation in price, especially for smaller carat values. However, there appears to be a positive relationship between carat value and price. We may, however, need to combine the diamond's weight with other features of the diamond in order to help determine the price. \n\nSince the linear regression model will be easier to construct with quantitative variables, we will not include the following features of the diamond into our linear model. However, it may be worthwhile to see what impact they have on price. We can first examine how the diamond cut affects price through a bar chart. \n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nsns.barplot(data=diamonds, x=\"cut\", y=\"price\")\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\n<Axes: xlabel='cut', ylabel='price'>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-12-output-2.png){width=601 height=429}\n:::\n:::\n\n\nInterestingly, it appears that the quality of the cut doesn't have much to do with the price. In fact, ideal cuts appear to have the lowest aggregated price. \n\nLet's also examine if the color of the diamond is a good predictor of price. \n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nsns.barplot(data=diamonds, x=\"color\", y=\"price\")\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\n<Axes: xlabel='color', ylabel='price'>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-13-output-2.png){width=601 height=429}\n:::\n:::\n\n\nHere, we see that as the color changes from D (worst) to J (best), the price tends to increase. \n\n# Constructing a Linear Model\n\nNow, we are ready to create a linear model, which will allow us to predict the price of a diamond given its carat, color, clarity, depth, etc. \n\nFirst, let's try to predict the price based on just its carat and depth. We can add more variables later, but let's keep it simple for now. We will begin by performing a train-test split. \n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nfrom sklearn.model_selection import train_test_split\nX = diamonds[[\"carat\", \"depth\"]]\ny = diamonds['price']\n\nX_train1, X_test1, y_train1, y_test1 = train_test_split(X, y, test_size=0.10, random_state=42)\n```\n:::\n\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nfrom sklearn.linear_model import LinearRegression\nlin_reg1 = LinearRegression().fit(X_train1, y_train1)\nlin_reg1.coef_,lin_reg1.intercept_\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n(array([7762.28116317, -103.52648711]), 4132.415850047029)\n```\n:::\n:::\n\n\nIt appears that a diamond's carat value has a strong positive correlation with the diamond's price, while the diamond depth has a negative correlation with price. Let's see how well this linear model predicts the price of samples in the test set. \n\nTODO: Add MSE metric\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\ny_pred1 = lin_reg1.predict(X_test1)\n\n# Compute the R^2 score for the test set. \nlin_reg1.score(X_test1, y_test1)\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\n0.8616559045890192\n```\n:::\n:::\n\n\nOur R^2 score is around 86%, which is pretty good. This metric indicates that most of the variability in the data can be explained by the model. \n\nLet's also construct a linear model using the diamond's dimensions (x, y, z) as the input variables and price as the output variable. \n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\nX = diamonds[['x', 'y', 'z']]\ny = diamonds['price']\n\nX_train2, X_test2, y_train2, y_test2 = train_test_split(X, y, test_size=0.10, random_state=42)\n\nlin_reg2 = LinearRegression().fit(X_train2, y_train2)\nlin_reg2.coef_, lin_reg2.intercept_\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\n(array([2789.14417141,  211.45956175,  265.86458654]), -14207.749973068772)\n```\n:::\n:::\n\n\nAs the dimensions of the diamond increase, its price also tends to increase. This makes intuitive sense, since larger diamonds are probably worth more than smaller diamonds.\n\nBelow are the predictions for this second linear model. \n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\ny_pred2 = lin_reg2.predict(X_test2)\nlin_reg2.score(X_test2, y_test2)\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\n0.7931234273030509\n```\n:::\n:::\n\n\nAgain, we get an R^2 score of around 80%. It could be better, but it's certainly not bad. \n\n# Visualizations of Linear Model\n\nNow, I will present a few visualizations of the diamonds dataset. I will start by plotting the carat and depth values and observing how they affect price. \n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\nax = sns.scatterplot(data=diamonds, x=\"carat\", y=\"depth\", hue=\"price\", size=\"price\")\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-19-output-1.png){width=585 height=429}\n:::\n:::\n\n\nWe can immediately see that as the diamond carat increases, the price tends to increase. This can be established due to the darker dots beginning from ~1 carat and extending until ~5 carats. The relationship between depth and price is less apparent. \n\nNow, let's visualize the relationship between the dimensions of the diamond (x, y, z) and price. We can begin by visualizing the price values between each pair of the diamond's dimensions (e.g. x vs. y, x vs. z, and y vs. z). \n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\nax = sns.scatterplot(data=diamonds, x=\"x\", y=\"y\", hue=\"price\", size=\"price\")\nax.set_ylim(ymin=3,ymax=11);\nax.set_xlim(xmin=3, xmax=11);\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-20-output-1.png){width=593 height=434}\n:::\n:::\n\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\nax = sns.scatterplot(data=diamonds, x=\"x\", y=\"z\", hue=\"price\", size=\"price\")\nax.set_ylim(ymin=1, ymax=9);\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-21-output-1.png){width=578 height=434}\n:::\n:::\n\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\nax = sns.scatterplot(data=diamonds, x=\"y\", y=\"z\", hue=\"price\", size=\"price\")\nax.set_xlim(xmin=3,xmax=12);\nax.set_ylim(ymin=1,ymax=8);\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-22-output-1.png){width=585 height=434}\n:::\n:::\n\n\nFrom the three plots above, it appears that as the dimensions of the diamond increase, the price tends to increase as well. Let's plot all three dimensions, along with price, to get a comprehensive view of how the dimensions affect price. \n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\nfig = plt.figure(figsize=(8,8))\nax = fig.add_subplot(projection='3d')\n\nscatter = ax.scatter(diamonds['x'], diamonds['y'], diamonds['z'], marker='o', c=diamonds['price'])\nax.set_xlabel('x')\nax.set_ylabel('y')\nax.set_zlabel('z')\nax.set_zlim3d(zmax=5)\nfig.colorbar(scatter, label=\"Price\", orientation='horizontal')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-23-output-1.png){width=614 height=592}\n:::\n:::\n\n\nThe 3-D plot above supports our conclusion. \n\n# Constructing a Nonlinear Model\n\nNow let's try using a nonlinear model to predict the diamond price. We can focus on the DecisionTreeRegressor model. To avoid overfitting, let's set the max_depth for this tree to be 2.  \n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\nfrom sklearn.tree import DecisionTreeRegressor\n\n# First, split the data into a train set and a test set. \nX_train_nl, X_test_nl, y_train_nl, y_test_nl = train_test_split(X, y, test_size=0.10, random_state=42)\n\n# Construct the DecisionTreeRegressor model and fit the training data. \ntree_reg = DecisionTreeRegressor(max_depth=2, random_state=42)\ntree_reg.fit(X_train_nl, y_train_nl);\n```\n:::\n\n\nJust like we did with our linear models, let's compute the score for our model and predict the data in the test set. \n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\ny_pred_nl = tree_reg.predict(X_test_nl)\ny_pred_nl\n```\n\n::: {.cell-output .cell-output-display execution_count=24}\n```\narray([ 1058.37929498,  6238.89262625, 12311.15592553, ...,\n       12311.15592553, 12311.15592553,  3251.84059003])\n```\n:::\n:::\n\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\ntree_reg.score(X_test_nl, y_test_nl)\n```\n\n::: {.cell-output .cell-output-display execution_count=25}\n```\n0.8317539986753625\n```\n:::\n:::\n\n\nOur decision tree has an R^2 value of around 83%. It looks like it performs similarly to the linear models we previously constructed. \n\nTODO: Visualize Decision Tree Regressor model. \n\nNow, let's try visualizing our predictions against the true labels. We'll just focus on the first 100 data points in order to make our plot less noisy. \n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\n# ax = range(len(ytest))\nx_data = range(100)\nplt.plot(x_data, y_pred_nl[:100], label=\"predicted diamond price\")\nplt.plot(x_data, y_test_nl[:100], label=\"actual diamond price\")\nplt.title(\"actual diamond price and diamond price comparison\")\nplt.xlabel('price observation index')\nplt.ylabel('price value')\nplt.legend(loc='best',fancybox=True, shadow=True)\nplt.grid(True)\nplt.show()  \n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-27-output-1.png){width=610 height=449}\n:::\n:::\n\n\nIt seems that the predicted prices are more or less in the same range as the actual prices. However, it appears that the predictions tend to underestimate the price of expensive diamonds. \n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}